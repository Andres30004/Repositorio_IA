# -*- coding: utf-8 -*-
"""ART.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1apgHqYccBlDc68YAPRKduI8W2c1q5C8v

ADAPTATIVE RESONANCE THEORY
"""

import numpy as np
import matplotlib.pyplot as plt

#Paso 1: definir parametros y pesos

X_train = np.array([[1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],#1
                   [1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1],#1
                   [1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0],#1
                   [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],#2
                   [0,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1],#2
                   [1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1],#2
                   [1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0],#3
                   [1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0],#3
                   [0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],#4
                   [0,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0]])#4

n = np.shape(X_train)[1] #neuronas entrada
m = 2 #neuronas salida
limite = 10 #limite de neuronas que se pueden crear
#Inicializar los pesos backward y fordward
pesos_forward = [np.ones((m,n))* (1/(1+n))]
pesos_backward = [np.ones((m,n))]
#Parametro de vigilacia
p = 0.1

#Neuronas en la capa de entrada y salida
F1 = np.zeros(n) #Genera un vector con n elementos
F2 = np.zeros(m) #Genera un vector con m elementos

#Paso 2: Fase de reconocimiento

for i in range(len(X_train)):
  sample =  X_train[i]
  F1 = sample


k = []
# for j in range(pesos_f[0].shape[0]): se calcula el valor de n, pero directamente n, pero directamente n puede
# puede cambiar si se añade una nueva neurona Por tanto se recalcula
for j in range(pesos_forward[0].shape[0]):
  # calculo de valor de activación
  u_sum_forward = np.dot(F1, pesos_forward[0][j]) # fila con todas sus columnas
  k.append((u_sum_forward,j)) #Va a ir guardando todos los valores de activación e indices en una lista para compararlos y ver cual es el mas grande

# Se ordena de mayor a menor los valores de activacion
# k = sorted(k, reverse=True)

k_g = [index for _, index in sorted(k, reverse = True)] #Reservado para recorrer pero no guardar, va a recorrer, ordenar y dar los indices ordenados

# Paso 3: Fase de comparacion
#Se define una bandera que en caso de que alguna de las neuronas pase el test de similitud se pondra en True y saltara a la actualizacion de pesos
#Si ninguna neurona pasa el test se agrega una nueva neurona
flag = False

for i in k_g: #recorre los indices de mayor a menor en k
  u_sum_backward = np.dot(F1, pesos_backward[0][i])
  sum = np.sum(F1) #ahi estan guardados los samples
  R = u_sum_backward / sum
  #Radio de similitud
  if R >= p:
    flag = True
    break
#En caso de que no se cumpla el True se debe de agregar una nueva neurona
if not flag:
  lim = len(k_g)
  if (lim<= limite):
    #al hacer la multiplicacion de los vectores esto deben de dar lo mismo que X o caracteristicas y despues si se divide con el vector b debe de dar 1 en el radio de similitud
    Ncol_F = F1.copy() #tiene los valores de la entrada equivalente a X
    Ncol_B = np.ones(F1.size) #tiene los valores de la salida

    pesos_forward[0] = np.vstack((pesos_forward[0], Ncol_F))
    pesos_backward[0] = np.vstack((pesos_backward[0], Ncol_B))

    print(f"Front weights: \n({pesos_forward[0][lim]})\n")
    print(f"Back weights: \n({pesos_backward[0][lim]})\n")

    #Total de clases
    print(f"Total de clases\n{len(pesos_backward[0])}")

  #Si la bandera es verdadera actualizamos
  pesos_forward[0] = np.vstack((pesos_forward, Ncol_F))
  pesos_backward[0] = np.vstack((pesos_backward, Ncol_B))
#Si la bandera es verdadera entonces, se actualizan los pesos
else:
  ganadora = k_g[0]
  pesos_backward[0][ganadora] = pesos_backward[0][ganadora]*F1
  pesos_forward[0][ganadora] = pesos_backward[0][ganadora] / (1/2+np.sum(pesos_backward[0][ganadora]))
  print(f"Front weights: \n({pesos_backward[0][0]})\n")
  print(f"Back weights: \n({pesos_backward[0][0]})\n")
print(f"The Predicted label is: {ganadora}")
print("======="*14,"\n")

print(k)

##EXAMEN



#########esta no################
import numpy as np
import matplotlib.pyplot as plt


PATRON_1 = np.array([[1,1,1,1,1,1,1],
             [1,0,1,1,1,0,1],
             [1,0,1,1,1,0,1],
             [1,1,1,1,1,1,1],
             [1,0,1,1,1,0,1],
             [1,0,0,0,0,0,1],
             [1,1,1,1,1,1,1]]).flatten()

PATRON_1_RUIDO = np.array([[0,1,1,1,1,1,1],
                  [1,0,1,0,1,0,1],
                  [1,0,1,1,1,0,1],
                  [1,1,0,1,1,1,1],
                  [1,0,1,0,1,0,1],
                  [1,0,0,0,0,0,1],
                  [1,1,1,1,1,1,0]]).flatten()

PATRON_2 = np.array([[1,1,0,0,0,1,1],
             [1,1,0,1,0,1,1],
             [1,1,0,0,0,1,1],
             [1,1,0,1,0,1,1],
             [1,1,0,0,0,1,1],
             [1,1,0,1,0,1,1],
             [1,1,0,0,0,1,1]]).flatten()

PATRON_2_RUIDO =np.array([[1,1,0,0,0,1,1],
             [1,1,0,0,0,1,1],
             [1,1,0,0,0,1,1],
             [1,1,0,1,0,1,1],
             [1,0,0,0,0,1,1],
             [0,1,0,1,0,1,1],
             [1,1,0,0,0,1,1]]).flatten()

PATRON_3 = np.array([[1,0,0,0,0,0,1],
             [0,1,1,1,1,1,0],
             [0,1,1,0,1,1,0],
             [0,1,1,0,1,1,0],
             [0,1,1,0,1,1,0],
             [0,1,1,1,1,1,0],
             [1,0,0,0,0,0,1]]).flatten()


PATRON_3_RUIDO = np.array([[1,0,0,0,0,0,1],
                    [0,1,1,1,1,1,0],
                    [0,1,1,0,1,1,0],
                    [0,1,1,0,1,1,0],
                    [0,0,1,0,1,1,0],
                    [0,1,1,1,1,1,0],
                    [0,0,0,0,0,0,0]]).flatten()



PATRON_4 = np.array([[1,1,1,0,1,1,1],
             [1,1,0,0,0,1,1],
             [1,1,0,0,0,1,1],
             [1,0,0,0,0,0,1],
             [1,0,0,0,0,0,1],
             [1,1,1,0,1,1,1],
             [1,1,1,0,1,1,1]]).flatten()




PATRON_4_RUIDO = np.array([[1,1,1,0,1,1,1],
                  [1,1,0,0,0,1,1],
                  [1,1,0,0,0,1,1],
                  [1,0,0,0,0,0,1],
                  [1,0,0,0,0,0,1],
                  [0,1,1,0,1,1,0],
                  [0,1,1,0,1,1,0]]).flatten()



PATRON_5 = np.array([[1,1,1,0,1,1,1],
             [0,0,0,0,0,0,0],
             [0,1,1,1,1,1,0],
             [0,0,0,0,0,0,0],
             [1,1,1,0,1,1,1],
             [1,1,1,0,1,1,1],
             [0,0,0,0,0,0,0]]).flatten()



PATRON_5_RUIDO = np.array([[1,0,1,0,1,1,1],
                  [0,0,0,0,0,0,0],
                  [0,1,0,1,1,1,0],
                  [0,0,0,0,0,0,0],
                  [1,1,0,0,1,1,1],
                  [1,1,1,0,1,1,1],
                  [0,0,0,0,0,0,0]]).flatten()

X_train = np.vstack((PATRON_1, PATRON_1_RUIDO, PATRON_2, PATRON_2_RUIDO, PATRON_3, PATRON_3_RUIDO, PATRON_4, PATRON_4_RUIDO, PATRON_5, PATRON_5_RUIDO))

plt.imshow(PATRON_1, cmap='gray')

# Inicialización de parámetros
n = np.shape(X_train)[1]
m = 2

# Inicializar pesos
pesos_f = np.ones((m, n)) * (1 / (1 + n))
pesos_b = np.ones((m, n))

# Parámetro de vigilancia
p = 0.8


# Fase de reconocimiento y asignación de clases
clases_asignadas = []
neuronas_agregadas = 0

for sample_idx, sample in enumerate(X_train):
    # Calcular activaciones de las neuronas
    F1 = sample
    activaciones = np.dot(pesos_f, F1)

    # Inicializar el valor máximo de R
    R_max = -1
    k_max = -1

    # Fase de comparación para todas las neuronas
    for k in range(pesos_b.shape[0]):
        u_sum_b = np.dot(pesos_b[k], F1)
        sum_F1 = np.sum(F1)
        R = u_sum_b / sum_F1

        # Actualizar la neurona ganadora si la similitud es mayor
        if R > R_max:
            R_max = R
            k_max = k

    # Verificar si la neurona ganadora pasa el test de similitud
    if R_max > p:
        # Actualizar los pesos de la neurona ganadora
        pesos_b[k_max] = pesos_b[k_max] * F1
        pesos_f[k_max] = pesos_b[k_max] / (0.5 + np.sum(pesos_b[k_max]))
        clases_asignadas.append(k_max)
    else:
        # Añadir una nueva neurona
        pesos_f = np.vstack([pesos_f, F1 * (1 / (1 + n))])
        pesos_b = np.vstack([pesos_b, np.ones(F1.size)])
        clases_asignadas.append(len(pesos_f) - 1)  # Nueva neurona para la nueva clase
        neuronas_agregadas += 1

print(f"Total de neuronas agregadas: {neuronas_agregadas}")

plt.figure(figsize=(8, 6))
plt.imshow(X_train, cmap='gray', aspect='auto')

# Anotar las clases asignadas en cada fila
for i, clase in enumerate(clases_asignadas):
    plt.text(n + 0.5, i, f'Neurona {clase + 1}', va='center', color='red')

# Ajustar título, etiquetas y espaciado
plt.title('Matriz de Entrenamiento con Neuronas Asignadas')
plt.xlabel('Características')
plt.ylabel('Muestras (Clases)')
plt.xticks(np.arange(0, n, 1))
plt.yticks(np.arange(0, X_train.shape[0], 1))

# Ajustar márgenes
plt.subplots_adjust(left=0.1, right=0.85, top=0.9, bottom=0.1)
plt.show()